#load "primitives.jai";

PrimitiveSphere :: struct
{
    radius: float;
}

PrimitiveDisk :: struct
{
    radius: float;
}

PrimitiveBox :: struct
{
    vmin: Vector3;
    vmax: Vector3;
}

PrimitiveMesh :: struct
{
    indices: []u32;
    vertices: []Vertex3;
    blas: Acceleration_Structure;
}

PrimitiveShape :: union
{
    sphere : PrimitiveSphere;
    disk   : PrimitiveDisk;
    box    : PrimitiveBox;
    mesh   : PrimitiveMesh;
}

Primitive :: struct
{
    type        : Primitive_Type;
    xform       : Transform;
    material_id : MaterialID;
    shape       : PrimitiveShape;
}

Bitmap :: Simp.Bitmap;

Texture_Format :: enum u32
{
    UNKNOWN;
    R8_UNORM;
    R8G8B8_UNORM;
    R32_FLOAT;
    R32G32B32_FLOAT;
}

Texture2D :: struct
{
    format    : Texture_Format;
    width     : u32;
    height    : u32;
    stride    : u32;
    scale     : Vector2;
    constants : [2]Vector3;
    data      : *u8;
}

SurfaceProperties :: struct
{
    color                : Vector3;
    metalness            : float;
    diffuse_roughness    : float;
    specular_weight      : float;
    specular_color       : Vector3;
    specular_roughness   : float;
    specular_anisotropic : float;

    emission_strength    : float;
    emission             : Vector3;

    //specular        : float;
    //subsurface      : float;
    //sheen           : float;
    //sheen_tint      : float;
    //clearcoat       : float;
    //clearcoat_gloss : float;
}

Material :: struct
{
    color                : Texture2D;
    metalness            : Texture2D;
    diffuse_roughness    : Texture2D;
    specular_weight      : Texture2D;
    specular_color       : Texture2D;
    specular_roughness   : Texture2D;
    specular_anisotropic : Texture2D;

    emission             : Texture2D;
    emission_strength    : Texture2D;

    //specular        : Texture2D(float);    
    //ior             : Texture2D(float);
    //subsurface      : Texture2D(float);    
    //sheen           : Texture2D(float);
    //sheen_tint      : Texture2D(float);
    //clearcoat       : Texture2D(float);
    //clearcoat_gloss : Texture2D(float);    
}

PathTracerConfig :: struct
{
    width           : int = 1280;
    height          : int = 720;
    multisamples    : u32 = 16;
    max_depth       : s32 = 5;
    flat_background := false;
}

Tone_Map_Type :: enum u32
{
    LINEAR;
    REINHARD;
}

Scene :: struct
{
    camera:  Camera;
    config:  PathTracerConfig;
    tonemap: Tone_Map_Type = .REINHARD;
    bitmap:  Bitmap;

    materials   : [..]Material;
    environment : Texture2D;
    flat_background_color := Vector3.{0.5, 0.5, 0.5};
    exposure := 2.0; // @todo: to Camera?

    primitives : [..]Primitive;

    tlas       : Acceleration_Structure;
    mapped     : [..]Primitive;

    rgbx_mem   : *void;
    rgbx       : []Vector4;
}

HitFace :: enum u32
{
    FRONT;
    BACK;
}

HitInfo :: struct
{
    p           : Vector3;
    t           : float;
    n           : Vector3;
    dpdu        : Vector3;
    dpdv        : Vector3;
    u           : float;
    v           : float;
    face        : HitFace;
    material_id : MaterialID;
}

#scope_file

IntersectPrimitive :: (primitive: Primitive, world_origin: Vector3, world_dir: Vector3, tmin: float, tmax: float) -> HitInfo
{
    origin := TransformPoint(primitive.xform.inverse, world_origin);
    dir    := TransformVector(primitive.xform.inverse, world_dir);

    intersect: Intersect_Info = ---;

    if #complete primitive.type ==
    {
        case .SPHERE;
            intersect = IntersectSphere(primitive.shape.sphere.radius, origin, dir, tmin, tmax);

        case .DISK;
            intersect = IntersectDisk(primitive.shape.disk.radius, origin, dir, tmin, tmax);

        case .BOX;
            intersect = IntersectBox(primitive.shape.box.vmin, primitive.shape.box.vmax, origin, dir, tmin, tmax);

        case .MESH;
            intersect = IntersectMesh(primitive.shape.mesh.indices, primitive.shape.mesh.vertices, primitive.shape.mesh.blas, origin, dir, tmin, tmax);
    }

    info := HitInfo.{ t = -1 };

    if (intersect.t >= 0.0)
    {
        // @todo: May be transform the minimum hit only??
        info.p            = TransformPoint(primitive.xform.forward, intersect.p);
        info.n            = TransformVector(transpose(primitive.xform.inverse), intersect.n);
        info.dpdu         = TransformVector(primitive.xform.forward, intersect.dpdu);
        info.dpdv         = TransformVector(primitive.xform.forward, intersect.dpdv);
        info.n            = normalize(info.n);
        info.dpdu         = normalize(info.dpdu); // @todo: are these necessary to normalize?
        info.dpdv         = normalize(info.dpdv);
        info.t            = intersect.t;
        info.u            = intersect.u;
        info.v            = intersect.v;
        info.face         = .FRONT;
        info.material_id  = primitive.material_id;

        if (dot(world_dir, info.n) > 0.0)
        {
            info.n    = -info.n;
            info.face = .BACK;
        }
    }

    return info;
}

#scope_export

IntersectBVH :: (nodes: []BVH_Node, primitives: []Primitive, origin: Vector3, dir: Vector3, tmin: float, tmax: float) -> HitInfo, int
{
    visited := 0;
    info := HitInfo.{ t = -1 };

    if nodes.count
    {
        nodes_stack : [64]u32 = ---;

        top : u32 = 1;
        nodes_stack[0] = 0;
        inv_dir := Vector3.{1.0 / dir.x, 1.0 / dir.y, 1.0 / dir.z};

        while top > 0
        {
            top -= 1;
            node := nodes[nodes_stack[top]];

            visited += 1;

            if (Hits(origin, inv_dir, node.bbox, tmin, tmax))
            {
                if (node.num_primitives)
                {
                    for 0..node.num_primitives-1
                    {
                        primitive := primitives[node.first_child_or_primitive + it];
                        current   := IntersectPrimitive(primitive, origin, dir, tmin, tmax);
                        if (current.t >= 0.0)
                        {
                            tmax = current.t;
                            info = current;
                        }
                    }
                }
                else
                {
                    assert(top + 2 < nodes_stack.count);
                    nodes_stack[top + 0] = node.first_child_or_primitive + 1;
                    nodes_stack[top + 1] = node.first_child_or_primitive + 0;
                    top += 2;
                }
            }
        }
    }

    return info, visited;
}

IntersectScene :: (scene: Scene, origin: Vector3, dir: Vector3, tmin: float, tmax: float) -> HitInfo, int
{
    hit, num_visited := IntersectBVH(scene.tlas.nodes, scene.mapped, origin, dir, tmin, tmax);
    return hit, num_visited;
}

#import "Random";
